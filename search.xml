<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Time,Clock and Ording ：时间是个本质问题。</title>
      <link href="/2018/08/21/time/"/>
      <url>/2018/08/21/time/</url>
      <content type="html"><![CDATA[<p>论文地址：<a href="https://citemaster.net/get/10b50274-7bc5-11e5-8aa1-00163e009cc7/p558-lamport.pdf" target="_blank" rel="noopener">Time, Clocks, and the Ordering of Events in a Distributed System</a></p><p>分布式系统的扛鼎之作，指导了日后所有的分布式系统的设计与思考方式，我先读《多核编程艺术》第三章，现在想来，里面提出的几种一致性与发生顺序。觉得十分神奇，妹想到！还是Leslie Lamport搞得（How old are you!)<br>这篇文章的方法我个人感觉几乎没有什么可以实践的可能，同步的消息交互方式，Fault tolerance几乎没有。。。这篇文章NB的地方就是站得高，指导我们的日后所有的设计方向。<br>（未完待续。。。。</p>]]></content>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chubby：分布式，去耦合，工程与妥协。</title>
      <link href="/2018/08/20/chubby/"/>
      <url>/2018/08/20/chubby/</url>
      <content type="html"><![CDATA[<p>首先，论文地址：<a href="http://static.usenix.org/legacy/events/osdi06/tech/full_papers/burrows/burrows.pdf" target="_blank" rel="noopener">The Chubby lock service for loosely-coupled distributed system</a>  </p><p>这篇paper论述了一些chubby实现上除了paxos以外的一些设计，关于paxos的设计与取舍上是另外一篇论文，链接在此：<a href="http://www8.cs.umu.se/kurser/5DV153/HT14/literature/chandra2006paxos.pdf" target="_blank" rel="noopener">Paxos made live: an engineering perspective</a>（以后会补一个阅读笔记）。其实我最开始读的是这篇讨论paxos算法的工程实现论文，chubby我一直没读，我当时搜了下chubby大概的功能，觉得搞清paxos大概就差不多可以搞个这样的差不多功能的错觉（不就是个paxos + KV吗，拍飞）。。。。昨天读了一下这篇，发现教我做人了。。。。怂了怂了。。。读完之后我就有一个感觉，工程是拖鞋，啊呸，妥协的艺术。。。。  </p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>chubby开篇就说这是一个分布式的锁服务。什么是锁？锁是一个排他性的独占时间的一个举措。分布式，和并行一样本质是个时间问题。通过锁来排他性的独占时间来吧不同对象同时发生的事件顺序转化为锁的的抢占顺序。这是一种比较粗暴的玩法，所有事件都只能通过持有锁的方式来排序。也就是锁的获取顺序来决定事件的时间排序。那什么是分布式锁？分布式锁其实就是就是给分布是各个节点排序时提供一个排序举措的机制，通过抢占它来重排。<br>chubby通过引入锁的抽象来帮助开发者快速做到分布式开发，文章讲了几个理由，我总结一下：</p><ul><li><p>开发者不需要读一打paxos made xxx 再来写应用，也不需要在代码里搞一堆兼容一致性协议库的东西，从单机一步升级到分布式！surprise！</p></li><li><p>去耦合，搞个外部的锁，出了啥问题，搞外部锁就可以了，不会影响其他开发者代码，升级也方便！wonderful！  </p></li></ul><p>其他的好处就算了，name server其实算个添头，至于减少客户的服务器数量我是不这么看的，你分布式至少要有两个服务器把？只有一个算J8分布式？两个服务器可以组主备复制（primary-backup）啊。当然其实这样就复杂了，可能出现多种协议。当然天下没有白得的午餐，好事不能让你占尽了。如果你的操作频繁需要通过一致性协议确认，性能肯定是远远不如直接使用一致性协议的，那咋办？不通过别。chubby鼓励粗粒度锁(Coarse-grained)而不是细粒度锁(Fine-grained)就是因为一致性频繁通过chubby确认的话，性能会比较感人。至于说细粒度可以通过粗粒度模拟也是好处就是扯淡了，粗粒度不能通过细粒度模拟？  </p><h2 id="实现设计"><a href="#实现设计" class="headerlink" title="实现设计"></a>实现设计</h2><p>chubby cell之间是通过multi-paxos之间确保数据的一致性。老规矩，只有master能够读写（如果使用epaxos等无master协议会不会有性能优化？）master通过租约来维持身份，租约多久超时之后就重新选举，反正套路都基本一样。。  </p><p>chubby 通过Unix的文件格式来暴露对外的接口，我觉得这个点就很有意思。我在这里不会讨论文中的通过文件暴露接口的具体细节。但是这确实是个很有意思的玩法。其实设计我觉得分两个部分，一个是服务的逻辑组织通过Unix的文件与目录的关系来阻止。一个是通过文件描述法(file descriptor)来表达接口。后者其实还好，可以理解为对开发者的友好，或者说前者的附带品。通过文件与目录的关系表达锁之间的关系。给跨服务之间的transaction其实做好了铺垫。其实不要以为目录表达很直观。。。。底层作为KV，实现目录其实本身是增加了麻烦的。。。。至于什么目录的各种属性，临时文件，永久文件，看看就行了。。。。</p><p>下面具体讨论分布式锁的问题，我们知道，分布式稳定的状态就是不稳定。那么不稳定，很多通信，节点都是不稳定的。但是我们又要保证一致。怎么搞？文中提出两个方法：</p><ul><li><p>搞一个Sequencer。然后拿到锁的服务拿着这个Sequencer到处比较，发现失效了就代表锁没了。同理，把这个Sequencer搞失效也意味着这锁没了。</p></li><li><p>lock delay 异常丢锁之后，一定时间内不允许其他节点加锁，这样可以避免一些尚在活动的操作和新锁带来的新操作相互覆盖而不一致。  </p></li></ul><p>paper认为第一种是一种更好的方法，不错Sequencer确实是个更严谨的方法，不会带来额外的不可用。但是Sequencer实际上是加了一重耦合。无非是服务的上层拿住校检或者下层拿住校检。实际上是要对服务来进行额外的与chubby耦合。。。。而第二种拿available换了consistent，但我觉得更好，虽然paper认为这是个妥协的办法，但是如果对于每个任务都有一个超时上线的话，我觉得这种办法具有更好的普适性，去掉了上下层的耦合（我们的需求是不能有耦合。。。），当然你API幂等就皆大欢喜了。。  </p><p>Cache的是玩法我觉得最重要的还是失效与恢复机制，正好与chubby失效恢复机制和cache更新机制结合起来，这个有点意思，可以想下为啥是cache失效而不是其他办法。分布式系统的故障恢复肯定是个核心的问题。。我觉得他的恢复机制还是有点繁琐与复杂了，他自己后面也承认了。。。而且我也没搞懂为啥要阻塞keepalive，为什么不把定时器做到server里，chubby维护那么多阻塞的keepalive是否有必要？只要把时间差打好我觉得放那里都可以吧？  </p><p>数据库之类的写什么的是肯定可以极大地优化空间的，但是问题是这只能结合运用来具体展开，对着paper没啥好说的，，，，后面说keepalive流量恐怖。。如果要跟新个版本号之类的，写还是蛮恐怖的。。虽然提到了不及时更新keepalive数据，但是终究治标不治本。。</p><p>后面展开讲了下工程问题，优化上提到了代理(proxy)和分区(partitioning),这两个都是讲起来简单，实际上做起来非常感人的东西，不要看paper中轻描淡写，其实绝壁是坑，proxy与多个chubby之间的缓冲一致性的维护？proxy挂掉了之后，客户与chubby直连之后数据不一致的更新，反正绝壁坑。至于partitioning那就是坑中之坑，迁移肯定是动态得把，多个chubby cell之间参与把，分布式事务怎么维持？坑中之坑。。。。</p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>chubby的作者自己也承认自己是把现有的技术整合起来，而不是搞出来啥新技术。但是所谓工程也就是如此，工程更多强调对现有技术的整合与取舍（当然正确性是第一位的）。回顾全文，我们处处能看到取舍，妥协，去耦合。天下没有白得的午餐，CAP不能全站，你想cache加快，就可能导致数据不一致。你想Sequencer就得上下层加耦合。你想更好的性能就别用锁直接上一致性协议。很多分布式工程实际上都是如此取舍。  </p><p>其实可以更深入一点，往往就是乐观锁与悲观锁的区别。乐观提升平时性能，但是出了点error就可能异常麻烦，甚至导致长时间不可用。悲观的话就是平时性能差点，当时保证出事就不慌了，看你怎么求取舍。。。。所谓减少系统通信次数来性能优化不过就是乐观玩法，出事了可能造成的不可用时间也会变长。。而lock delay就是悲观玩法，通过放弃一定性能来保证consistent。。。。  </p><p>有人认为<a href="http://catkang.github.io/2017/09/29/chubby.html" target="_blank" rel="noopener">责任分散</a>也是一个特点。。。我是没感觉出来。。他说的故障恢复我比较同意，不一定要全持久化加重disk负担，但是我们也知道这是提高平时的效率，降低恢复时的效率的乐观玩法。。。。。</p><p>chubby提供了一个分布式的锁机制，大家一般都通过它来master select或者name server。回到最开始，最基础其实consistent protocol + kv ，但是这样设计的话可用性大概约等于0把。。。。。。文章讨论了很多工程中的优化，使得我做一个这个成了可能（大坑）。不过chubby的持久化结构其实paper没有提，我感觉这不是个简单东西。。。</p><p>chubby后来有zookeeper学他搞了自己一套，不过这玩意，正确性也确实很难保证。最好的方法肯定是TLA+之类的，但是难度太大。据说Amazon S3/ebs ，MS的cosmos都通过了证明。。zookeeper破司据说就被坑过两次。。。所以没事别自己瞎搞，别想不开。。。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="http://static.usenix.org/legacy/events/osdi06/tech/full_papers/burrows/burrows.pdf" target="_blank" rel="noopener">The Chubby lock service for loosely-coupled distributed system</a>  </p></li><li><p><a href="http://www8.cs.umu.se/kurser/5DV153/HT14/literature/chandra2006paxos.pdf" target="_blank" rel="noopener">Paxos made live: an engineering perspective</a>  </p></li><li><p><a href="http://catkang.github.io/2017/09/29/chubby.html" target="_blank" rel="noopener">Chubby的锁服务</a>  </p></li><li><p><a href="http://baotiao.github.io/2017/09/12/distributed-lock/" target="_blank" rel="noopener">talk about consensus algorithm and distributed lock</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2018/05/11/hello-world/"/>
      <url>/2018/05/11/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p><br>其实没啥搭建过程，首先从github上拉了个github page，然后hexo操作一波，详情参看<a href="https://www.zhihu.com/question/59088760/answer/265741938" target="_blank" rel="noopener">这里</a><br><br>    然后就是找主题，找了N个都不满意，最后找到了这个<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material</a>  <br><br>    啊，几个作者好小啊，比我还小，还有个高中生大佬，github 4位数 star ，羡慕死了!!<br><br>    最后折腾这个主题折腾了两天，毕设GG，毕业无能   <br><br>    暂时挂在github page 上吧，但是不会一直这样，计划做一个分布式的后端（恩，又挖坑了，反正也不填对吧）</p><h2 id="博客用处"><a href="#博客用处" class="headerlink" title="博客用处"></a>博客用处</h2><p> <br>首先第一个可以来存点图对吧，妈妈再也不怕我的图换电脑丢了（不对，不应该是资料吗）<a href="/gallery">这里</a><br><br>    然后可以写些流水账（区块链orz），记录自己干了啥。<br><br>    然后还可以网上卖萌来讨钱（创收一刚!)<a href="/money">可爱，打钱！</a><br><br>    技术？不存在的，我不能写些我不会的东西吧，这里只有糊shit，哪有技术？<a href="/reading">reading list</a><br><br>    要是有个像垠神那个一样微博的功能就好了QAQ，但是我又不会前端，这个主题又没有提供</p>]]></content>
      
      
        <tags>
            
            <tag> 流水账 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
